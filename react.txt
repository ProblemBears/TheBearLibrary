What is React.js?
	-A JavaScript library for building UI (client-side JS library)
	-Extra functionality can be added via community packages. For things other than UI (e.g: routing)
	-Competitors: *Angular - component based UI; uses TypeScript; has more features; overkill for small projects
		      *Vue.js - less popular than React & Angular
	-Course Outline: (Divided to these three categories)
		*Basics & Foundations:
			**Components & Building UI
			**Working w/ Events & Data: "props" and "state"
			**Styling React Apps & Components
			**Intro into "React Hooks"
		*Advanced Concepts:
			**Side Effects, "Refs" & More React Hooks
			**React's Context API & Redux
			**Forms, Http Requests & "Custom Hooks"
			**Routing, Deployment, NextJS, & More
		*Summaries and Refreshers

3 - REACT BASICS & WORKING WITH COMPONENTS
	-Creating a new React Project				*cd into a directory where you want to create the project folder
	 (with dummy code):					*Do:	$ npx create-react-app some-directory-name	//Then cd into it and do $npm start

4 - A (PRETTY DEEP DIVE) INTRODUCTION TO Next.js
	-Creating a New Next.js				-How:		1) Have NPM installed
	 Project & App:							2) Go to a directory where you want to spawn a new project directory
									3) To auto create:	$ npx create-next-app@latest
									4) It prompts you to name the directory

	-Adding First Pages:				-Prereq:	* Delete the following:
										** /pages/api directory
										** /styles/Home.module.css
										** /pages/index.js	//We delete this to show Next.js Routing

							-What/How:	* Next.js reads the pages directory structure to define routes:
										Ex: We put the following files in '/pages' and they have routes:
											** index.js = domain.com/
											** news.js = domain.com/news

									* Then, we can render the page by exporting A React component like usual (index.html):
										function HomePage() {
											return <h1>Hello World!</h1>
										}
										export default HomePage;

							-Important:	* YOU CAN OMIT 'react' imports in Next.js
									* The code is pre rendered so HTML code is sent giving us the advantage of no initial loading
									  flickers and improved SEO

	-Adding Nested Paths &				-What/How:	* Folders can be added to '/pages' which in turn makes nested routes. If you want to still get 
	 Pages (Nested Routes):						  get a route of the folder name, then we add index.js in that folder

	-Creating Dynamic Pages				-What/How:	* The  issue of Dynamic Routes (for things like different productId's) arises. We handle it by naming
	 (with Parameters):						  files with square brackets:
												[someIdentifier].js

									*We can alsp have dynamic folders:
												[someFolderIdentifier]

	-Extracting Dynamic				-What/How:	* To extract the Paramter Value of our Dynamic Page. We make use of a Next.js special React hook:
	 Parameter Values:							import { useRouter } from 'next/router';

										function SomeComponent(){
											const router = useRouter();
											
											const saveParam = router.query.someIdentifier	//the thing we put in the [] in our filename
										}

	-Linking Between Pages:				-What/How:	* Yes we could use anchor tags to link between pages, but that would send the server new requests and
									  this app would not be a single page app

									* Instead, we do:
										import Link from 'next/link';

										//and instead of <a> we use...
										<Link href="/someFolder/someFile"> Text Here </Link>	// where '/' is the pages folder 

							-Note:		* We know our code asks the server for a new page if when we refresh, we see a cross pop out quickly.
									  With this <Link> that should not happen.

									* Keeping it as a SPA allows us to keep States across pages

	-The "_app.js" File &				- What:		* We use a Wrapper component to "wrap" our Navigation bar onto Next pages we have. Although, if we had many
	 Layout Wrapper:						  pages, you could see how this could become cumbersome. Enter the _app.js file

							-IMPORTANT:	* "_app.js" is a special file in Next.js that resides in "/pages". It acts as a root component that
									  receives destructured props of the form {Component, pageProps} where:
										** Component - holds the actual page content that should be rendered. (so it changes)
										** pageProps - are specific props any of our pages might be getting

							-Conclusion:	* Therefore, since the Component prop in _app.js contains what is to be rendered. We could simply wrap our
									  Header Component around it

	-Using Programmatic 				-What/How:	* In our Component for giving a button some link to it's own ID Page. We can use 'useRouter()'
	 (Imperative) Navigation:					  imported again from 'next/router'. Then in our Handler for that React Component we can specify
										$ router.push('/' + props.id);	//pushes a new page on the Page Stack based on the ID passed through props

							-Continue:	* Now we just need to add a Next.js '/page' route at that path of the route pushed

							-Convention:	* Use JSX on '/components' and also style them there so that our '/pages' stay lean. 

	-How Pre-rendering Works &			-Problem:	* We want to pre-render a page with data, but with data for which we havee to wait, and we have to tell
	 Which Problem We Face:						  Next.js when we're done waiting. If we don't then the HTML we yield will not contain our data and therefore
									  be bad for SEO

	-Data fetching for Static Pages:		-What/How:		*Next.js gives us Two Forms of Pre-rendering which can be used to control how pages are rendered:
											1) Static Generation -  * A Page Component is pre-rendered when you build the App for deployment.
														* But, if you need to wait for data(fetching). In the Page component where
														  you need to do that, you must export a special function:
															export function getStaticProps(){};
														  NextJS Looks for this function, and if it finds it, it executes this
														  function during this pre-rendering process. (It gets called before even
														  your Page Component).
														* getstaticProps() is allowed to be async. It can run any code a server 
														  would run (ex: file system, authentication). Simply, because this code
														  is executed during the build process, it never executes in a visitor's machine.
															** So you could fetch data from an API here
															** You always have to return an object of the form:
																{
																props: {propsObjectToBeUsedInPageComponent}
																}
															   Which makes that build time prop insertion available in
															   Your props passed to your Page Component
											2) Server-side Rendering

	-More on Static Site Generation:		-Analysis:	* To build for deployment we'd have to run:
	(SSG)									$ npm run build

									* After doing that, we get log output that shows we generated static pages, and it shows us which ones.

							-Problem(s):	* Since the SSG is built at runtime, if we update the data that it feeds to props, then it would not
									  be updated:
										** A FIX (Incremental Static Generation): In our return object, add the following:
											revalidate: 10		//Which means it will be regenerated every 10 seconds on the server

							-End Result:	* export async function getStaticProps() {
										// fetch data from an API
										return {
											props: {
												meetups: DUMMY_MEETUPS
											},
											revalidate: 10
										};
									 }

	-Exploring Server-side Rendering		-What:		* If we want to dynamically update the Page not during the build process or every couple of seconds we use
	 (SSR) with "getServerSideProps":				  getServerSideProps(). It's similar to the previous one except it runs always on the server after deployment.
									  You could run any server side code in  that function (even sensitive info stuff)

									* You can also pass in the "context" parameter, which gives you access too context.req & context.res

							-Which:		* getStaticProps() is faster

	-Working with Param for SSG Data		-What:		* You can't get the URL of a Dynamic Parameter with the help of useRouter() because this is a build-time function.
	 Fetching:							  Therefore, you use the context parameter.

							-How:		* In the export async function getStaticProps(context), before the return do:
										const id = context.params.someFileIdentifier;

							-Continue:	* But when we set it in our return object. We get the error "getStaticPaths is required"...

	-