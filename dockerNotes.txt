DOCKER IMAGES & CONTAINERS: THE CORE BUILDING BLOCKS
	-Images and Containers:				* Images are the blueprints for containers, the contain the code + required tools/runtimes
	 What and Why?					* Containers are the running "unit of software"
							* So IMAGES are used to create MULTIPLE CONTAINERS

	-Using and Running External			* We can Find images
	 (Pre-Built) Images:					** Coworkers hand it to us
								** DockerHub - Where we can search community images
									*** EX: 	- We can run NodeJS's image via a container by using the command:
											  " docker run node " (anywhere in terminal) which runs a container
											  and pulls the image if not already locally installed.

											- The program is running but since containers isolate it inside, we
											  can't see it. To verify then, we do "docker ps -a" to see all processes

											- "docker run -it node" to actually INTERACT with the container's process

	-Node.js App-					* Typically we build on top of or create an image based on another image (such as those on the DockerHub)
	 Building Our					* EX:
	 Own Image with						* Normally, for a Node.js app. We would npm install dependencies and then do "node app.js" to run
	 a Dockerfile:							  our app (which may be a server)

								* Instead, with Docker, we can create our own IMAGE that contains our app AND ALSO utilizes the NODE.JS
								  Image. To do this we do the following:

									1) In your App's root directory: Create a file called "Dockerfile" (The VSCode Docker Extension helps)
										-The "Dockerfile" - contains the instructions for Docker that we want to execute when we build
												    our own image.

									2) Write the following code in "Dockerfile" (w/ explanations):
										FROM node				** We build on an image that exist on our system or the DockerHub
															** "Hey Docker, in my own image I want to start by pulling the node Image.

										COPY . /app				** COPY - Which files that are in our local machine should go in the external Image

															** .  - Source to be copied, in this case . refers to the directory where the
																Dockerfile is located (our App's entire contents except for the Dockerfile)

															** /app  - Destination of the copy, where . refers to the root directory inside of the
														   		   FROM'd image (Every image/container) has its own internal filesystem
														    	*** It's actually recommended to put it in some subfolder so here we replace
														            "." with "/app (an absolute path)"

										WORKDIR /app				** Sets the working directory to the FROM'd Image's app directory where we copied our
													  		   App files into previously.

															** If we had set this before the COPY then we could've just used "COPY . ."

										RUN npm install				** NOW because we're in the correct working directory where we copied our files into
													   		   we can run "npm install" successfully.
															** This runs when the Image is created

										EXPOSE 80				** "When this container is started, expose port 80 to our local system"
															** This is necessary because since Docker containers are isolated, they
															   even have their own ports, which is why we have to "expose them" to our system ports

										CMD ["node", "server.js"]		X WE CAN NOT do RUN node server.js because the Dockerfile serves as instructions of how to setup an Image
										  			  		  THE CONTAINER IS THE THING WE RUN!!! Instead, To tell a container to "run" something when it starts
													  		  we us CMD (which works exactly like RUN but has weird syntax)

															* This should always be the last command in your Dockerfile

	-Running a container				* To create the Image:		Terminal -> Directory Where "Dockerfile" resides
	 based on our own				  (using the Dockerfile)	$ docker build .
	 Image:						
							* To run the newly
							  created image:		$ docker run <image-id>

							* To Shut down a		$ docker ps				//To show the running containers & their info
							  running container:		$ docker stop <container-name> 		//might take a while

							* To actually make		$ docker run -p <port>:<docker_exposed_port> <image_id> 
							  the image run
							  on a PORT:


	-Images are read only:				* We have to rebuild our image everytime we change our code because the COPY command is what
							  acutally updates the Image. (There is a faster way later)

	-Understanding Image Layers:			* Docker caches every instruction in the Dockerfile, therefore, when we rebuild it only executes
							  instructions that need to reexecute (ex: Only Copy executes when you change your code and rebuild)/
							  This is what is meant by layer based.

	-Stopping & Restarting				$ docker |command|--help
	 Containers:					$ docker start <container_name>		-	to restart an "Exited" container (in contast to the "run" command which starts a new container)

	-Understanding Attached
	 & Detached Containers:				- Attached refers to the Container blocking your terminal sesssion when you run it it, because it serves as a log for your container
							- By default, "run" is in attached mode, and "start" is detached
							- To "run" in detached mode "-d" flag:
								$ docker run -p 8000:80 -d <image_id>
							- To "start" in attached mode "-a" flag:
								$ docker start -a <container_name>
							- To attach yourself to a detached container:
								$ docker attach <container_name>
							- To get container logs without attaching:
								$ docker logs <container_name>
								$ docker logs -f <container_name> 	// to "follow" aka attach

	-Entering Interactive Mode:			- (Switching to Python) we have the scenario where the code states that user input will be required
							  so we have to make our Docker Container "interactive":
								1) Dockerfile for Python:
									FROM python

									WORKDIR /app

									COPY . /app

									CMD [ "python", "rng.py"]

								2) Generate an Image that runs in interactive mode and w/ a tty terminal:
									$ docker run -i -t <image-id>		//-i and -t can be shorthanded to -it for interactive mode terminal tty.


								3) The process stops when the input is put in. We can re-"start" it in attached mode, but A TIDBIT IS that when we 
								   generated the image with "run -i -t", the -i flag is forgotten sp we have to respecify it when we "start" as follows:
									$ docker start -a -i <container_name>

	-Deleting Images & Containers:			-Delete a container:
								$ docker stop <container-name> 		//if the container is running
								$ docker rm <container-name1> <container_name2> //etc...

							-Delete all stopped containers:
								$ docker container prune

							-Display all images:
								$ docker images
							-Remove images:
								$ docker rmi <image_id1> <image_id2> //etc...			//You can only remove images that don't have containers (even stopped ones)
							-Remove all images that don't have running containers:
								$ docker image prune

	-Removing Stopped Containers			$ docker run -p 3000:80 -d --rm <image_id>
	 Automatically:						** The --rm  flag removes containers automatically after stopping

	-A Look Behind the Scenes -			- Multiple Containers using the same Image share the code given by the Image. They make their own
	 Inspecting Images:				  thin layer above the image where they can change things (like their own filesystem)
							- To inspect an image:
								$ docker image inspect <image_id>

	-Copying Files into &				-Copy files/folders into or out of a running container:
	 From a Container:					$docker cp <sourcePath>/. <container-name>:/<containerDestPath>		//where "/." copies all files in that sourcePath of you local machine
									*reverse the source and dest paths to copy from a container to the local machine

	-Naming & Tagging				-When you run a container you can name it with:
	 Containers and Images:					$ docker run -p 3000:80 -d --rm --name <new_name> <image_id>

							-To name(tag) an image while building:
								$ docker build -t goals:v1 .
								* Convention says tags should be named in this format:	repoName : tag	(ex: node:v14 )
								  DOCKER know this format so it'll set the REPOSITORY and TAG fields when we search up
								  all docker images
							- After giving a Docker Image a Repo:Tag , we can use that to run containers and not use <image_id>

	-Sharing Images - Overview:			1) We can share the whole directory that includes the Dockerfile so that people can run the 
							   Docker commands to build an image out of it

							2) We can share a built image: we just download it and run it