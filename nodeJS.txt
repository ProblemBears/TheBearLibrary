IMPROVED DEVELOPMENT WORKFLOW & DEBUGGING:
	-Understanding NPM Scripts:			-Process:		1) npm init
										2) Go to package.json
										3) Insert a key/value in "scripts"
										4) Finally, you can do "npm run <key>" where the key is the name of your script
										   you specified in "scripts"

							-Notes:			* Creating a "start" script is an exception where you don't have to use "run"
										  so you could simply do "npm start"

							-Notes:			* They key/values should not have whitespace
										* You should wrap in double quotes

	-Installing 3rd Party Packages:			-Process:		1) Go to the root of your App
										2) $ npm install <package>
											Ex1) $ npm install nodemon --save-dev 	//since this is needed for easy save/restart during development
							
							-Notes:			* Flags: --save 	: to install as a production dependency
											 --save-dev	: to install for development	(Creates devDependncies in your package.json)
											 -g 		: install to your machine

	-Using Nodemon for Autorestarts:		-Why:			* We would have to stop/rerun our server code manually otherwise

							-Process:		1) Create a "start" script with the value "nodemon app.js"
										2) Use "npm start" to run that script, which runs nodemon
										3) Now when we save a project, the server automatically reruns

							-Notes:			* You can not use nodemon in terminal if you install it as a local dependency. You would have to install it as
										  a global dependency to use it in terminal


WORKING WITH EXPRESS.JS:
	-What is Express.js?:				-Why?:			* Server logic is complex! 
										* It's a framework that does the heavylifting

							-Alternatives:		* Express.js (is the most popular)
										* Vanilla Node.js 
										* Adonis.js (Laravel inspired from PHP)
										* Koa
										* Sails.js

	-Installing Express.js:				-Process:		1) npm install --save express

										2) const express = require('express');		(Ctrl + Click to see the code)
										   const http = require('http');

										3) const app = express();			(Since the express module exports a function we have to execute
														 	 	  for initializing a manager)
										4) const server = http.createServer(app)	//app is a valid requestHandler
										5) server.listen(3000);

	-Adding Middleware:				-Definition:		* Middleware - an incoming request is "funneled" through functions by Express.js

							-Notes:			* Instead of having one request handler, there's a possibility of hooking up multiple functions that the request
										  will go through until it is sent as a response

							-Process:		1) To put a function in the Middleware:
											$ app.use();	* Param 1: A function that receives three arguments - (req, res, next) => {}
														** next: Is a function that will be passed to this param function
													         	 by Express.js. Used to move on to the next middleware

										2) To allow the request to travel on to the "next" middleware:
											$ (Inside the app.use() Parameter 1 function) write next().
										   So if we have another app.use() along the way. the next() allows it to "funnel" to the next Middleware

	-How Middleware Works:				-What:			* We can now send a response with Express.js (which is easier than in vanilla w/ a utinility function ".send()"

							-Process:		1) In the last middleware function do:
											$ res.send('<h1> Hello from Express! </h1>)

							-Notes:			* The Response Headers are automatically set by Express (although we could set it manually with res.setHeader() )	

	-Express.js - BTS:				-Important:		* Instead of http.createServer(app).listen(3000). We can use express to do this instead:
											$app.listen(3000);
											** Which means we also don't need the ('http') import

										* The official code can be seen in "Github -> Express -> express/lib/application.js"

	