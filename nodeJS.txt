IMPROVED DEVELOPMENT WORKFLOW & DEBUGGING:
	-Understanding NPM Scripts:			-Process:		1) npm init
										2) Go to package.json
										3) Insert a key/value in "scripts"
										4) Finally, you can do "npm run <key>" where the key is the name of your script
										   you specified in "scripts"

							-Notes:			* Creating a "start" script is an exception where you don't have to use "run"
										  so you could simply do "npm start"

							-Notes:			* They key/values should not have whitespace
										* You should wrap in double quotes

	-Installing 3rd Party Packages:			-Process:		1) Go to the root of your App
										2) $ npm install <package>
											Ex1) $ npm install nodemon --save-dev 	//since this is needed for easy save/restart during development
							
							-Notes:			* Flags: --save 	: to install as a production dependency
											 --save-dev	: to install for development	(Creates devDependncies in your package.json)
											 -g 		: install to your machine

	-Using Nodemon for Autorestarts:		-Why:			* We would have to stop/rerun our server code manually otherwise

							-Process:		1) Create a "start" script with the value "nodemon app.js"
										2) Use "npm start" to run that script, which runs nodemon
										3) Now when we save a project, the server automatically reruns

							-Notes:			* You can not use nodemon in terminal if you install it as a local dependency. You would have to install it as
										  a global dependency to use it in terminal

							-IMOPORTANT:		* Restart nodemon if you install a new package


WORKING WITH EXPRESS.JS:
	-What is Express.js?:				-Why?:			* Server logic is complex! 
										* It's a framework that does the heavylifting

							-Alternatives:		* Express.js (is the most popular)
										* Vanilla Node.js 
										* Adonis.js (Laravel inspired from PHP)
										* Koa
										* Sails.js

	-Installing Express.js:				-Process:		1) npm install --save express

										2) const express = require('express');		(Ctrl + Click to see the code)
										   const http = require('http');

										3) const app = express();			(Since the express module exports a function we have to execute
														 	 	  for initializing a manager)
										4) const server = http.createServer(app)	//app is a valid requestHandler
										5) server.listen(3000);

	-Adding Middleware:				-Definition:		* Middleware - an incoming request is "funneled" through functions by Express.js

							-Notes:			* Instead of having one request handler, there's a possibility of hooking up multiple functions that the request
										  will go through until it is sent as a response

							-Process:		1) To put a function in the Middleware:
											$ app.use();	* Param 1: A function that receives three arguments - (req, res, next) => {}
														** next: Is a function that will be passed to this param function
													         	 by Express.js. Used to move on to the next middleware

										2) To allow the request to travel on to the "next" middleware:
											$ (Inside the app.use() Parameter 1 function) write next().
										   So if we have another app.use() along the way. the next() allows it to "funnel" to the next Middleware

	-How Middleware Works:				-What:			* We can now send a response with Express.js (which is easier than in vanilla w/ a utinility function ".send()"

							-Process:		1) In the last middleware function do:
											$ res.send('<h1> Hello from Express! </h1>)

							-Notes:			* The Response Headers are automatically set by Express (although we could set it manually with res.setHeader() )	

	-Express.js - BTS:				-Important:		* Instead of http.createServer(app).listen(3000). We can use express to do this instead:
											$app.listen(3000);
											** Which means we also don't need the ('http') import

										* The official code can be seen in "Github -> Express -> express/lib/application.js"

	-Handling Different Routes:			-What:			* We want to handle request for different routes.

							-How:			* There are actually 4 overloads of app.use(), we were using the one with one argument. With 2 arguments we can specify
										  a path:
											$ app.use('/', (req, res, next) => {} );

							-Problems:		* Express reads the path '/' as a match even if there is more like '/app-js'. Therefore, in code, we can make the actual
										  '/app-js' and put it above the '/' code with no middleware.next(), so that it matches the actual path first and isn't
										  able to travel to the next. THIS IS MADE THIS WAY SO THAT WE CAN FUNNEL THINGS TO MULTIPLE PAGES IF WE NEED IT LIKE:
											** Putting '/' above a '/app-js' above another '/' Where the first '/' console logs ("this always runs")

	-Parsing Incoming Request:			-What/How:			* Handling a POST request:
												1) Have a page that has a form
												  (In this case we set it up through routes): 
													$ app.use('/add-product', (req, res, next) => {
														res.send('<form action="/product"><input type="text" name="title> <button type="submit"> Add Product </button> </form>');
												  	});

												2) Add a middleware that parses the request (this should usually be the first middleware for all routes):		
													a) npm install --save body-parser
													b) const bodyParser = require('body-parser');
													c) app.use(bodyParser.urlencoded(extended:false));		//Where this function yields a middleware function that parses and even calls next

												3) Now make a root based on the "action" of the form from (1):
													$ app.use('/product', (req, res, next) => {
														console.log(req.body
														res.redirect('/'); //To redirect to the home page
													  });

												*) Now since the req is parsed using (2), (3) is able to use it

							-Next:			* This route currently would listen to any request, but we onlly want to use it for 
										  a POST request...

	-Limiting Middleware Execution			-Syntax:		* To do POST requests for a route:
	 to POST Requests:								$ app.post('/',()=>{});		//instead of app.use()

										* To do GET requests use: $ app.get

										* Others are: delete, patch, put

	-Using Express Router:				-What:			*Typically, we want to put our routing code throughout different files and import in the main
										 app.js file. Express.js actually gives us a way of outsourcing Express logic to other files.

							-Process:		1) Convention says we put route logic in a "/routes" directory
										2) Add files like : 
													* "admin.js" - where we'll store routes only accessible to admins
													* "shop.js" - routes that the user can see
										3) For each of these files:
											a) const express = require('express');

											b) const router = express.Router();
												* This is like a mini-Express app pluggable into the main one

											c) router.use('/someRoute' (req, res, next)=>{}) //Can still use get, post, etc.

											d) module.exports = router;

										4) In your main file (app.js):
											a) const adminRoutes = require('./routes/admin.js');

											b) app.use(adminRoutes)		//because adminRoutes is a valid middleware function
															//just as before, the order still matters

							-Notes:			* get, post , etc. do exact matching for the path in contrast to 'use'

	-Adding a 404 Error Page:			-What:			*Previously we swicthed all our routes to have matching paths with get or post. We want
										 the power of 'use' for error pages when we go to invalid routes

							-How:			* At the end of your main app.js do:
											$ app.use((req, res, next) => {
												res.status(404).send('<h1>Page not found</h1>');
											  });

	-Filtering Paths:				-What/How:		* Sometimes route paths have common starting paths like '/admin/add-product'. We could
										  add this path to every route but that would be tedious. Instead, we could let external
										  routes have normal route names, and in the main App.js, we can use a "filter path"
										  in our app.use('/admin', ()=>{})

	-Serving HTML Files:				-Notes:			* ModelViewController conventions creates a directory called "View" where we put html files

							-Process:		1) const path = require('path');	// A NodeJS core module that helps generate paths

										2) In your routes do:
											$ res.sendFile( path.join( __dirname, 'views', 'somePage.html')
												** We can not use absolute paths because '/' refers to the device root.
												   Instead, we make use of NodeJS's GLOBAL VARIABLE: __dirname which
												   generates an absolute path to the current file directory, and the
												   path.join() simply generates a path with concatenated parameters
												   ASWELL as generates valid paths for both Windows and Linux systems

	-Using a Helper Function for			-What/How:		* We don't want to tediously generate a root path by manipulating __dirname. Instead we generate a root path:
	 Navigation:									1) Create a '/util' directory, and create a 'path.js' file in it.
											2) In that file write:
												const path = require('path');

												module.exports = path.dirname(process.mainModule.filename);	   //where process is globally available via Node

											3) In any file you want to use it import it like so:
												const rootDir = require('pathToIt');

							-Notes: 			* process.mainModule.filename may be deprecated, instead possibly use:
											$ module.exports = path.dirname(require.main.filename);

	-Serving Files Statically				-What:			* We want to serve CSS files that connect to HTML files that we also serve. So we need to be able to serve 
										  files 'statically'

							-How:			1) Create a 'public' directory.
										2) In app.js we plug-in one of Express's built-in middleware (after our parser middleware/ before our page routes):
											$ app.use( express.static( pathToFolderWeWantToServeStatically ) );
										3) Make sure the html files have <style> tags with path links relative to the 'public' folder we served statically
										   (since Express forwards file request to the static folder)

							-Notes:			* Up until now the info we send has been private. Meaning if our route specified a file being served,
										  it would yield a 404 error.


THE MODEL VIEW CONTROLLER (MVC):
	-What is the MVC?:				-Definitions:		* Model - Represent your data in your code; work with your data (save, fetch, etc.)
										* View - What the user sees; decoupled from you Application code.
										* Controller - Connects your Models and Views.
										* Routes - Decide what Controller logic to execute

	-Adding Controllers:				-What:			* We don't want to put our Controller Logic into the files in our "/routes" directory, because the files there
										  would quickly get large. 

							-How:			1) Instead, we separate each file into a "/controllers" directory with respective files
										2) We export those functions using: $ export.someFuncName = (req, res, next) => {}
										3) We import those exports with $ const productsController = require('pathToController')
										4) We use the references of the functions with $ productsController.funcReference not execution

											